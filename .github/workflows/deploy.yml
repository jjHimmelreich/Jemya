name: ğŸš€ Deploy to Production

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      force_deploy:
        description: 'Force deploy even if tests failed'
        required: false
        default: false
        type: boolean
      image_tag:
        description: 'Docker image tag to deploy (defaults to latest main branch)'
        required: false
        type: string

  # Automatic trigger after CI passes
  workflow_run:
    workflows: ["ğŸ”„ Continuous Integration"]
    types:
      - completed
    branches: [main]

env:
  AWS_DEFAULT_REGION: eu-west-1
  ECR_REPOSITORY: jemya

jobs:
  # Check if deployment should proceed
  deployment-gate:
    name: ğŸšª Deployment Gate
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.gate.outputs.should_deploy }}
      image_tag: ${{ steps.gate.outputs.image_tag }}
      deploy_reason: ${{ steps.gate.outputs.deploy_reason }}
    
    steps:
    - name: ğŸšª Check deployment conditions
      id: gate
      run: |
        SHOULD_DEPLOY="false"
        DEPLOY_REASON=""
        IMAGE_TAG=""
        
        # Manual trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "ğŸ“‹ Manual deployment triggered"
          SHOULD_DEPLOY="true"
          DEPLOY_REASON="Manual deployment triggered by ${{ github.actor }}"
          
          # Use provided image tag or find the latest available image
          if [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
            echo "ğŸ·ï¸ Using specified image tag: $IMAGE_TAG"
          else
            # Use 'latest' tag for manual deployments to avoid commit SHA mismatches
            IMAGE_TAG="latest"
            echo "ğŸ·ï¸ Using latest image tag for manual deployment: $IMAGE_TAG"
            echo "ğŸ’¡ To deploy a specific version, use the 'image_tag' input parameter"
          fi
          
          # Check force deploy flag
          if [ "${{ inputs.force_deploy }}" = "true" ]; then
            echo "âš ï¸ Force deploy enabled - bypassing all checks"
            DEPLOY_REASON="$DEPLOY_REASON (FORCE DEPLOY - bypassed checks)"
          fi
        fi
        
        # Automatic trigger after CI
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "ğŸ“‹ Triggered by CI workflow completion"
          
          if [ "${{ github.event.workflow_run.conclusion }}" = "success" ]; then
            echo "âœ… CI workflow passed - proceeding with deployment"
            SHOULD_DEPLOY="true"
            DEPLOY_REASON="Automatic deployment after successful CI"
            # Use 'latest' since CI just pushed it as the latest successful build
            IMAGE_TAG="latest"
            echo "ğŸ·ï¸ Using 'latest' tag (matches CI build: ${{ github.event.workflow_run.head_sha }})"
          else
            echo "âŒ CI workflow failed - deployment cancelled"
            DEPLOY_REASON="Deployment cancelled - CI workflow failed: ${{ github.event.workflow_run.conclusion }}"
          fi
        fi
        
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "deploy_reason=$DEPLOY_REASON" >> $GITHUB_OUTPUT
        
        echo "ğŸ” Deployment Decision:"
        echo "   Should Deploy: $SHOULD_DEPLOY"
        echo "   Image Tag: $IMAGE_TAG"
        echo "   Reason: $DEPLOY_REASON"

    - name: ğŸ” Pre-deployment Infrastructure Check
      if: steps.gate.outputs.should_deploy == 'true'
      run: |
        echo "ğŸ” Infrastructure connectivity check (Session Manager)..."
        
        # Configure AWS credentials for the check
        export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
        export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
        export AWS_DEFAULT_REGION="${{ env.AWS_DEFAULT_REGION }}"
        
        # Check if EC2 instance exists and is running
        echo "ğŸ–¥ï¸ Checking EC2 instance status..."
        INSTANCE_INFO=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=jemya-instance" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].[InstanceId,PublicIpAddress,State.Name]' \
          --output text 2>/dev/null || echo "None None None")
        
        if [ "$INSTANCE_INFO" = "None None None" ] || [ -z "$INSTANCE_INFO" ]; then
          echo "âŒ No running Jemya EC2 instance found!"
          echo "ğŸ’¡ Deployment will fail - instance not available"
          exit 1
        fi
        
        INSTANCE_ID=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f1)
        PUBLIC_IP=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f2)
        STATE=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f3)
        
        echo "âœ… Found instance: $INSTANCE_ID ($STATE) at $PUBLIC_IP"
        
        # Test Session Manager connectivity
        echo "ğŸ”§ Testing Session Manager connectivity..."
        
        # Debug: Show current AWS identity
        echo "ğŸ” Current AWS identity:"
        aws sts get-caller-identity || echo "âŒ Failed to get caller identity"
        
        # Try to send command with detailed error handling
        echo "ğŸ” Attempting to send SSM command..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["echo Session Manager connectivity test"]' \
          --query 'Command.CommandId' \
          --output text 2>&1)
        
        if [[ $COMMAND_ID == *"Error"* ]] || [[ $COMMAND_ID == *"error"* ]]; then
          echo "âŒ Failed to send SSM command:"
          echo "$COMMAND_ID"
          echo "ğŸ’¡ This indicates a permissions issue with the GitHub Actions user"
          exit 1
        fi
        
        echo "âœ… Command sent successfully: $COMMAND_ID"
        
        # Wait for command completion
        sleep 5
        RESULT=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query '{Status:Status,Output:StandardOutputContent}' \
          --output text 2>&1)
        
        echo "ğŸ” Command result: $RESULT"
        
        # Check if both "Session Manager connectivity test" and "Success" are present
        if echo "$RESULT" | grep -q "Session Manager connectivity test" && echo "$RESULT" | grep -q "Success"; then
          echo "âœ… Session Manager connectivity confirmed"
        else
          echo "âŒ Session Manager connectivity failed"
          echo "Result details: $RESULT"
          echo "ğŸ’¡ Check that:"
          echo "   - Instance has SSM agent installed and running"
          echo "   - Instance has proper IAM role for Session Manager"
          echo "   - Security groups don't block Session Manager (port 443)"
          exit 1
        fi

  # Deploy to production environment
  deploy:
    name: ğŸš€ Deploy to ${{ inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    needs: deployment-gate
    if: needs.deployment-gate.outputs.should_deploy == 'true'
    
    environment:
      name: ${{ inputs.environment || 'production' }}
      url: https://${{ steps.discover-ec2.outputs.public_ip }}
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: âš™ï¸ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_DEFAULT_REGION }}

    - name: ğŸ” Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ğŸ” Verify Docker image exists
      run: |
        IMAGE_TAG="${{ needs.deployment-gate.outputs.image_tag }}"
        IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        
        echo "ğŸ” Verifying image exists: $IMAGE_URI"
        
        # Check ECR permissions first
        echo "ğŸ” Testing ECR access..."
        if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_DEFAULT_REGION }} > /dev/null 2>&1; then
          echo "âŒ Cannot access ECR repository. Check AWS permissions."
          echo "ğŸ’¡ Required permissions: ecr:DescribeRepositories, ecr:DescribeImages"
          exit 1
        fi
        
        # Check if specific image exists in ECR
        if aws ecr describe-images \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-ids imageTag=$IMAGE_TAG \
          --region ${{ env.AWS_DEFAULT_REGION }} > /dev/null 2>&1; then
          echo "âœ… Docker image found in ECR"
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV
        else
          echo "âŒ Docker image not found in ECR: $IMAGE_URI"
          echo ""
          echo "ğŸ’¡ Available images in repository:"
          if aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} \
            --query 'imageDetails[*].{Tags:imageTags,Pushed:imagePushedAt}' \
            --output table --region ${{ env.AWS_DEFAULT_REGION }} 2>/dev/null; then
            echo ""
          else
            echo "   (Could not list images - check ECR permissions)"
          fi
          
          # For manual deployments, suggest using 'latest' tag
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "ğŸ’¡ For manual deployment, try:"
            echo "   1. Use 'latest' as the image tag"
            echo "   2. Or run the CI workflow first to build image with tag: $IMAGE_TAG"
            echo "   3. Or specify an existing image tag in the deployment parameters"
          fi
          
          exit 1
        fi

    - name: ğŸ” Discover EC2 Instance
      id: discover-ec2
      run: |
        echo "ğŸ” Auto-discovering Jemya EC2 instance..."
        
        # Find running Jemya instance by tag
        INSTANCE_INFO=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=jemya-instance" \
                    "Name=instance-state-name,Values=running" \
          --query 'Reservations[0].Instances[0].[InstanceId,PublicIpAddress,PrivateIpAddress]' \
          --output text \
          --region ${{ env.AWS_DEFAULT_REGION }})
        
        if [ "$INSTANCE_INFO" = "None	None	None" ] || [ -z "$INSTANCE_INFO" ]; then
          echo "âŒ No running Jemya EC2 instance found!"
          echo "ğŸ’¡ Make sure your EC2 instance is running and tagged with Name=jemya-instance"
          exit 1
        fi
        
        # Parse instance info with better error handling
        INSTANCE_ID=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f1)
        PUBLIC_IP=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f2)
        PRIVATE_IP=$(echo "$INSTANCE_INFO" | cut -d$'\t' -f3)
        
        echo "âœ… Found Jemya EC2 instance:"
        echo "   Instance ID: '$INSTANCE_ID'"
        echo "   Public IP: '$PUBLIC_IP'"
        echo "   Private IP: '$PRIVATE_IP'"
        
        # Validate parsed values
        if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
          echo "âŒ Invalid Instance ID: '$INSTANCE_ID'"
          exit 1
        fi
        
        if [ -z "$PUBLIC_IP" ] || [ "$PUBLIC_IP" = "None" ]; then
          echo "âŒ Invalid Public IP: '$PUBLIC_IP'"
          exit 1
        fi
        
        # Set outputs for next steps
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "private_ip=$PRIVATE_IP" >> $GITHUB_OUTPUT

    - name: ğŸš€ Execute Deployment via Session Manager
      run: |
        # Get variables
        INSTANCE_ID="${{ steps.discover-ec2.outputs.instance_id }}"
        PUBLIC_IP="${{ steps.discover-ec2.outputs.public_ip }}"
        IMAGE_TAG="${{ needs.deployment-gate.outputs.image_tag }}"
        
        echo "ğŸš€ Deploying to EC2 instance via Session Manager:"
        echo "   Instance ID: '$INSTANCE_ID'"
        echo "   Public IP: '$PUBLIC_IP'"
        echo "   Docker Image: '${{ env.IMAGE_URI }}'"
        echo "   Reason: ${{ needs.deployment-gate.outputs.deploy_reason }}"

        # Export environment variables for the deployment script
        export SPOTIFY_CLIENT_ID="${{ secrets.SPOTIFY_CLIENT_ID }}"
        export SPOTIFY_CLIENT_SECRET="${{ secrets.SPOTIFY_CLIENT_SECRET }}"
        export SPOTIFY_REDIRECT_URI="${{ secrets.SPOTIFY_REDIRECT_URI }}"
        export OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"
        export ENVIRONMENT="production"
        
        # Deploy using aws_manager.py with the pre-built image (skip build phase)
        python3 aws/aws_manager.py deploy --image-tag "$IMAGE_TAG" --deploy-only

    - name: ğŸ” Verify Deployment
      run: |
        PUBLIC_IP="${{ steps.discover-ec2.outputs.public_ip }}"
        INSTANCE_ID="${{ steps.discover-ec2.outputs.instance_id }}"
        
        echo "ğŸ” Verifying Session Manager deployment..."
        VERIFICATION_FAILED=false
        
        # Test container health via Session Manager
        echo "ğŸ” Testing container status..."
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["docker ps --filter name=jemya-app --format \"{{.Names}}: {{.Status}}\""]' \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 5
        CONTAINER_STATUS=$(aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text 2>/dev/null || echo "FAILED")
        
        if echo "$CONTAINER_STATUS" | grep -q "Up"; then
          echo "âœ… Container is running: $CONTAINER_STATUS"
        else
          echo "âŒ Container is not running properly: $CONTAINER_STATUS"
          VERIFICATION_FAILED=true
        fi
        
        # Test application health (internal port)
        echo "ğŸ” Testing application health..."
        HEALTH_COMMAND_ID=$(aws ssm send-command \
          --instance-ids "$INSTANCE_ID" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=["curl -s -o /dev/null -w \"%{http_code}\" http://localhost:8501 && echo \" - Application responding\" || echo \" - Application not responding\""]' \
          --query 'Command.CommandId' \
          --output text)
        
        sleep 5
        HEALTH_RESULT=$(aws ssm get-command-invocation \
          --command-id "$HEALTH_COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query 'StandardOutputContent' \
          --output text 2>/dev/null || echo "FAILED")
        
        if echo "$HEALTH_RESULT" | grep -q "200.*responding"; then
          echo "âœ… Application health check passed: $HEALTH_RESULT"
        else
          echo "âŒ Application health check failed: $HEALTH_RESULT"
          VERIFICATION_FAILED=true
        fi
        
        # Test HTTPS access (if nginx is configured)
        echo "ğŸ” Testing public HTTPS access..."
        if curl -f -k --connect-timeout 10 --max-time 30 "https://$PUBLIC_IP/" > /dev/null 2>&1; then
          echo "âœ… HTTPS access is working (nginx configured)"
        else
          echo "âš ï¸  HTTPS not accessible - nginx may not be configured (this is OK for Session Manager deployment)"
          echo "ğŸ’¡ Application is accessible internally on port 8501"
        fi
        
        # Fail the workflow if critical verifications failed
        if [ "$VERIFICATION_FAILED" = true ]; then
          echo ""
          echo "âŒ DEPLOYMENT VERIFICATION FAILED!"
          echo "ğŸ” Check the following via Session Manager:"
          echo "  â€¢ Container logs: aws ssm start-session --target $INSTANCE_ID"
          echo "  â€¢ Then run: docker logs jemya-app"
          echo "  â€¢ Check container status: docker ps -a"
          echo ""
          exit 1
        fi
        
        echo ""
        echo "ğŸ‰ Session Manager deployment verification passed!"
        echo "ğŸ“¦ Container is running and application is healthy"
        echo "ğŸ”— Internal access: http://localhost:8501 (on EC2)"
        echo "ğŸŒ Public access: https://$PUBLIC_IP (if nginx configured)"

    - name: ğŸ“Š Deployment Summary
      run: |
        echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### âœ… Deployment Completed Successfully" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ¯ **Environment**: \`${{ inputs.environment || 'production' }}\`" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ·ï¸ **Image Tag**: \`${{ needs.deployment-gate.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ“ **Reason**: ${{ needs.deployment-gate.outputs.deploy_reason }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ğŸŒ Application URLs" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ”— **HTTPS (Primary)**: [https://${{ steps.discover-ec2.outputs.public_ip }}](https://${{ steps.discover-ec2.outputs.public_ip }})" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ”„ **HTTP (Redirect)**: [http://${{ steps.discover-ec2.outputs.public_ip }}](http://${{ steps.discover-ec2.outputs.public_ip }}) â†’ HTTPS" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ğŸ’» Infrastructure Details" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ†” **EC2 Instance**: \`${{ steps.discover-ec2.outputs.instance_id }}\`" >> $GITHUB_STEP_SUMMARY
        echo "ğŸŒ **Public IP**: \`${{ steps.discover-ec2.outputs.public_ip }}\`" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ“¦ **Container**: \`jemya-app\` (internal port 8501)" >> $GITHUB_STEP_SUMMARY
        echo "ï¿½ **Deployment Method**: AWS Session Manager (no SSH required)" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ”’ **SSL**: Via nginx reverse proxy (if configured)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ğŸ‰ **Deployment completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')**"

  # Notification job (optional - runs on both success and failure)
  notify:
    name: ğŸ“¢ Notify Results
    runs-on: ubuntu-latest
    needs: [deployment-gate, deploy]
    if: always() && needs.deployment-gate.outputs.should_deploy == 'true'
    
    steps:
    - name: ğŸ“¢ Deployment Results
      run: |
        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "ğŸ‰ Deployment successful!"
          echo "ğŸŒ Application URL: https://${{ needs.deploy.outputs.public_ip || 'check-ec2-instance' }}"
          echo "ğŸ·ï¸ Deployed image: ${{ needs.deployment-gate.outputs.image_tag }}"
        else
          echo "âŒ Deployment failed!"
          echo "ğŸ” Check the deployment logs above for details"
        fi
        
        echo ""
        echo "ğŸ“‹ Deployment Details:"
        echo "   Trigger: ${{ github.event_name }}"
        echo "   Actor: ${{ github.actor }}"
        echo "   Environment: ${{ inputs.environment || 'production' }}"
        echo "   Image Tag: ${{ needs.deployment-gate.outputs.image_tag }}"
        echo "   Reason: ${{ needs.deployment-gate.outputs.deploy_reason }}"